use async_trait::async_trait;
use barcoders::generators::image::*;
use barcoders::generators::svg::*;
use barcoders::sym::code39::*;
use google_drive::GoogleDrive;
use macros::db;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use crate::airtable::{AIRTABLE_BASE_ID_SWAG, AIRTABLE_SWAG_INVENTORY_ITEMS_TABLE};
use crate::core::UpdateAirtableRecord;
use crate::db::Database;
use crate::schema::swag_inventory_items;
use crate::utils::get_gsuite_token;

#[db {
    new_struct_name = "SwagInventoryItem",
    airtable_base_id = "AIRTABLE_BASE_ID_SWAG",
    airtable_table = "AIRTABLE_SWAG_INVENTORY_ITEMS_TABLE",
    match_on = {
        "item" = "String",
        "size" = "String",
    },
}]
#[derive(Debug, Insertable, AsChangeset, PartialEq, Clone, JsonSchema, Deserialize, Serialize)]
#[table_name = "swag_inventory_items"]
pub struct NewSwagInventoryItem {
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub name: String,
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub size: String,
    #[serde(default)]
    pub current_stock: i32,
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub item: String,
    #[serde(
        default,
        skip_serializing_if = "String::is_empty",
        serialize_with = "airtable_api::barcode_format_as_string::serialize",
        deserialize_with = "airtable_api::barcode_format_as_string::deserialize"
    )]
    pub barcode: String,

    #[serde(default, skip_serializing_if = "String::is_empty", deserialize_with = "airtable_api::attachment_format_as_string::deserialize")]
    pub barcode_png: String,
    #[serde(default, skip_serializing_if = "String::is_empty", deserialize_with = "airtable_api::attachment_format_as_string::deserialize")]
    pub barcode_svg: String,

    /// This is populated by Airtable.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub link_to_item: Vec<String>,
}

/// Implement updating the Airtable record for a SwagInventoryItem.
#[async_trait]
impl UpdateAirtableRecord<SwagInventoryItem> for SwagInventoryItem {
    async fn update_airtable_record(&mut self, record: SwagInventoryItem) {
        if !record.link_to_item.is_empty() {
            self.link_to_item = record.link_to_item;
        }

        // This is a funtion in Airtable so we can't update it.
        self.name = "".to_string();
    }
}

/// Sync software vendors from Airtable.
pub async fn refresh_swag_inventory_items() {
    let db = Database::new();

    // Get gsuite token.
    let token = get_gsuite_token("").await;

    // Initialize the Google Drive client.
    let drive_client = GoogleDrive::new(token);

    // Figure out where our directory is.
    // It should be in the shared drive : "Automated Documents"/"rfds"
    let shared_drive = drive_client.get_drive_by_name("Automated Documents").await.unwrap();
    let drive_id = shared_drive.id.to_string();

    // Get the directory by the name.
    let drive_rfd_dir = drive_client.get_file_by_name(&drive_id, "swag_inventory_barcodes").await.unwrap();
    let parent_id = drive_rfd_dir.get(0).unwrap().id.to_string();

    // Get all the records from Airtable.
    let results: Vec<airtable_api::Record<SwagInventoryItem>> = SwagInventoryItem::airtable().list_records(&SwagInventoryItem::airtable_table(), "Grid view", vec![]).await.unwrap();
    for inventory_item_record in results {
        let mut inventory_item: NewSwagInventoryItem = inventory_item_record.fields.into();

        // Generate the barcode.
        // "Name" is automatically generated by Airtable from the item and the size.
        if !inventory_item.name.is_empty() {
            inventory_item.barcode = inventory_item
                .name
                .to_uppercase()
                .replace(' ', "")
                .replace('/', "")
                .replace('(', "")
                .replace(')', "")
                .replace('-', "")
                .replace("'", "")
                .trim()
                .to_string();

            // Generate the barcode svg and png.
            let barcode = Code39::new(&inventory_item.barcode).unwrap();
            let png = Image::png(80); // You must specify the height in pixels.
            let encoded = barcode.encode();

            // Image generators return a Result<Vec<u8>, barcoders::error::Error) of encoded bytes.
            let png_bytes = png.generate(&encoded[..]).unwrap();
            let mut file_name = format!("{}.png", inventory_item.name);

            // Create or update the files in the google_drive.
            let png_file = drive_client.create_or_update_file(&drive_id, &parent_id, &file_name, "image/png", &png_bytes).await.unwrap();
            inventory_item.barcode_png = format!("https://drive.google.com/open?id={}", png_file.id);

            // Now do the SVG.
            let svg = SVG::new(200); // You must specify the height in pixels.
            let svg_data: String = svg.generate(&encoded).unwrap();
            let svg_bytes = svg_data.as_bytes();

            file_name = format!("{}.svg", inventory_item.name);

            // Create or update the files in the google_drive.
            let svg_file = drive_client.create_or_update_file(&drive_id, &parent_id, &file_name, "image/svg+xml", &svg_bytes).await.unwrap();
            inventory_item.barcode_svg = format!("https://drive.google.com/open?id={}", svg_file.id);
        }

        let mut db_inventory_item = inventory_item.upsert_in_db(&db);
        db_inventory_item.airtable_record_id = inventory_item_record.id.to_string();
        db_inventory_item.update(&db).await;
    }
}

#[cfg(test)]
mod tests {
    use crate::swag_inventory::refresh_swag_inventory_items;

    #[ignore]
    #[tokio::test(flavor = "multi_thread")]
    async fn test_cron_swag_inventory_items() {
        refresh_swag_inventory_items().await;
    }
}
